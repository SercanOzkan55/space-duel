<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Neon Space Duel â€” AI</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="wrap">
    <header>
      <h1>NEON SPACE DUEL</h1>

      <div class="topbar">
        <div class="help">
          <span class="kbd">WASD</span> Move
          <span class="sep">|</span>
          <span class="kbd">Space</span> Jump
          <span class="sep">|</span>
          <span class="kbd">F</span> Shoot
        </div>

        <div class="namebox">
          <label for="pname">Name</label>
          <input id="pname" maxlength="12" placeholder="Sercan?" />
          <button id="applyName" class="btn">Apply</button>
        </div>
      </div>
    </header>

    <div class="stage">
      <canvas id="c" width="980" height="420"></canvas>

      <!-- Win/Lose Overlay -->
      <div id="overlay" class="overlay hidden">
        <div class="panel">
          <div id="resultTitle" class="resultTitle">YOU WIN</div>
          <div id="resultSub" class="resultSub">Score 0:0</div>
          <div class="panelBtns">
            <button id="restartBtn" class="btn big">Restart</button>
            <button id="closeBtn" class="btn ghost">Close</button>
          </div>
          <div class="tinyHint">Tip: Jump dodges bullets. AI learns your rhythm ðŸ‘€</div>
        </div>
      </div>
    </div>

    <footer>
      <span id="status">First to 5 wins. No blood, just lasers âœ¨</span>
    </footer>
  </div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const statusEl = document.getElementById("status");
  const overlay = document.getElementById("overlay");
  const resultTitle = document.getElementById("resultTitle");
  const resultSub = document.getElementById("resultSub");
  const restartBtn = document.getElementById("restartBtn");
  const closeBtn = document.getElementById("closeBtn");

  const nameInput = document.getElementById("pname");
  const applyName = document.getElementById("applyName");

  // HiDPI
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  function resize() {
    const cssW = Math.min(980, window.innerWidth - 24);
    const cssH = Math.round(cssW * 0.43);
    canvas.style.width = cssW + "px";
    canvas.style.height = cssH + "px";
    canvas.width = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", resize);
  resize();

  const W = () => parseInt(canvas.style.width);
  const H = () => parseInt(canvas.style.height);

  // Controls
  const keys = new Set();
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    keys.add(k);
    if (["arrowup","arrowdown","arrowleft","arrowright"," "].includes(e.key)) e.preventDefault();
  });
  window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

  // Stars (use base coords then scale in draw)
  const stars = Array.from({length: 140}, () => ({
    x: Math.random() * 980,
    y: Math.random() * 420,
    r: Math.random() * 1.6 + 0.2,
    s: Math.random() * 0.6 + 0.1
  }));

  const neon = {
    cyan: "#00E5FF",
    deep: "#06121f",
    white: "#eaf7ff",
    purple: "#A78BFA",
    red: "#FF3D81",
    green: "#33FFB1"
  };

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;

  // Physics
  const groundY = () => H() - 18;

  function makePlayer(x, color, controls, isAI=false) {
    return {
      x, y: groundY(),
      vx: 0, vy: 0,
      w: 26, h: 46,

      hp: 100,
      score: 0,

      face: 1,
      color,

      cd: 0,          // shoot cooldown frames
      jumpCd: 0,      // jump buffer
      onGround: true,

      label: isAI ? "AI" : "P1",
      controls,
      isAI,

      // AI memory / tuning
      ai: {
        jitter: 0,
        aimBias: (Math.random()*2-1) * 10,
        aggression: 0.65,     // shoot tendency
        dodge: 0.85,          // dodge tendency
        strafe: 0.55          // move left-right tendency
      }
    };
  }

  // Player1
  const p1 = makePlayer(110, neon.cyan, {
    left:"a", right:"d", up:"w", down:"s", shoot:"f", jump:" "
  }, false);

  // Enemy AI (replaces Player2)
  const bot = makePlayer(980-110, neon.purple, null, true);
  bot.face = -1;

  let playerName = "P1";
  applyName.addEventListener("click", () => {
    const v = (nameInput.value || "").trim();
    playerName = v.length ? v.slice(0,12) : "P1";
    p1.label = playerName;
    statusEl.textContent = `Name set: ${playerName}. First to 5 wins.`;
  });
  nameInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") applyName.click();
  });

  const bullets = [];
  function shoot(p) {
    if (p.cd > 0) return;
    p.cd = 12;

    const speed = 9.5;
    const bx = p.x + p.face * (p.w/2 + 8);
    const by = p.y - p.h*0.55;

    bullets.push({
      x: bx, y: by,
      vx: p.face * speed,
      vy: 0,
      r: 3.2,
      life: 95,
      color: p.color,
      owner: p
    });
  }

  function jump(p) {
    if (!p.onGround) return;
    p.onGround = false;
    p.vy = -11.2; // jump impulse
  }

  function resetRound(winner) {
    p1.x = 110; p1.y = groundY(); p1.vx = p1.vy = 0; p1.hp = 100; p1.face = 1; p1.cd = 0; p1.onGround = true;
    bot.x = W()-110; bot.y = groundY(); bot.vx = bot.vy = 0; bot.hp = 100; bot.face = -1; bot.cd = 0; bot.onGround = true;
    bullets.length = 0;

    if (winner) {
      winner.score++;
      statusEl.textContent = `Point for ${winner===p1 ? playerName : "AI"} â€” Score ${p1.score}:${bot.score}`;
    } else {
      statusEl.textContent = `First to 5 wins.`;
    }
  }

  function resetMatch() {
    p1.score = 0;
    bot.score = 0;
    hideOverlay();
    resetRound(null);
  }

  restartBtn.addEventListener("click", resetMatch);
  closeBtn.addEventListener("click", hideOverlay);

  function showOverlay(type) {
    // type: "win" | "lose"
    overlay.classList.remove("hidden");
    if (type === "win") {
      resultTitle.textContent = "YOU WIN";
      resultTitle.dataset.type = "win";
    } else {
      resultTitle.textContent = "YOU LOSE";
      resultTitle.dataset.type = "lose";
    }
    resultSub.textContent = `Final Score ${p1.score}:${bot.score}`;
  }
  function hideOverlay() {
    overlay.classList.add("hidden");
  }

  resetRound();

  function rectHitCircle(rx, ry, rw, rh, cx, cy, cr) {
    const px = clamp(cx, rx, rx+rw);
    const py = clamp(cy, ry, ry+rh);
    const dx = cx - px, dy = cy - py;
    return dx*dx + dy*dy <= cr*cr;
  }

  function updatePlayerHuman(p) {
    const acc = 0.72;
    const maxV = 6.6;
    const friction = 0.86;

    const L = keys.has(p.controls.left);
    const R = keys.has(p.controls.right);
    const U = keys.has(p.controls.up);
    const D = keys.has(p.controls.down);
    const S = keys.has(p.controls.shoot);
    const J = keys.has(p.controls.jump);

    if (L) p.vx -= acc;
    if (R) p.vx += acc;
    if (U) p.vy -= 0.25; // tiny "float" feel (optional)
    if (D) p.vy += 0.25;

    // Jump buffer
    if (p.jumpCd > 0) p.jumpCd--;
    if (J && p.onGround && p.jumpCd === 0) {
      p.jumpCd = 10;
      jump(p);
    }

    p.vx *= friction;
    p.vx = clamp(p.vx, -maxV, maxV);

    // gravity
    if (!p.onGround) p.vy += 0.62;
    p.vy = clamp(p.vy, -12, 12);

    p.x += p.vx;
    p.y += p.vy;

    p.x = clamp(p.x, 18, W()-18);

    // ground collision
    if (p.y >= groundY()) {
      p.y = groundY();
      p.vy = 0;
      p.onGround = true;
    }

    // face enemy
    p.face = (bot.x > p.x ? 1 : -1);

    if (p.cd > 0) p.cd--;
    if (S) shoot(p);
  }

  function nearestThreatTo(p) {
    // find nearest enemy bullet heading towards p
    let best = null;
    let bestT = 1e9;
    for (const b of bullets) {
      if (b.owner === p) continue;
      const toward = Math.sign(b.vx) === Math.sign(p.x - b.x);
      if (!toward) continue;
      const dx = Math.abs(b.x - p.x);
      if (dx < bestT) {
        bestT = dx;
        best = b;
      }
    }
    return best;
  }

  function updateBotAI(p) {
    // Lightweight behavior:
    // - keep distance
    // - strafe
    // - dodge bullets by jumping or moving
    // - shoot when aligned

    const target = p1;
    const acc = 0.62;
    const maxV = 6.1;
    const friction = 0.88;

    const dist = target.x - p.x;

    // Face target
    p.face = (target.x > p.x ? 1 : -1);

    // Basic spacing: try to keep ~280px
    const desired = 280;
    const tooClose = Math.abs(dist) < desired * 0.75;
    const tooFar   = Math.abs(dist) > desired * 1.25;

    // Threat detection
    const threat = nearestThreatTo(p);
    const threatNear = threat && Math.abs(threat.x - p.x) < 140 && Math.abs(threat.y - p.y) < 70;

    // Movement intent
    let move = 0; // -1 left, +1 right
    if (tooClose) move = -Math.sign(dist);    // back off
    else if (tooFar) move = Math.sign(dist);  // chase
    else {
      // strafe
      p.ai.jitter += (Math.random() - 0.5) * 0.25;
      p.ai.jitter = clamp(p.ai.jitter, -1, 1);
      if (Math.random() < p.ai.strafe) move = Math.sign(p.ai.jitter);
    }

    // Dodge: if bullet approaching, step aside / jump
    if (threatNear && Math.random() < p.ai.dodge) {
      move = Math.sign((p.x - threat.x) || 1); // move away from bullet x
      if (p.onGround && Math.random() < 0.55) jump(p);
    }

    // Apply movement
    p.vx += move * acc;
    p.vx *= friction;
    p.vx = clamp(p.vx, -maxV, maxV);

    // gravity
    if (!p.onGround) p.vy += 0.62;
    p.vy = clamp(p.vy, -12, 12);

    p.x += p.vx;
    p.y += p.vy;

    p.x = clamp(p.x, 18, W()-18);

    if (p.y >= groundY()) {
      p.y = groundY();
      p.vy = 0;
      p.onGround = true;
    }

    // Shoot logic: shoot if roughly aligned and random aggression
    const aimY = (target.y - target.h*0.55) - (p.y - p.h*0.55);
    const aligned = Math.abs(aimY) < 22; // since bullets go straight
    const hasLine = Math.abs(dist) < 520; // range
    const wants = Math.random() < (0.05 + 0.08*p.ai.aggression);

    if (p.cd > 0) p.cd--;
    if (aligned && hasLine && wants) shoot(p);
  }

  function updateBullets() {
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      b.x += b.vx;
      b.y += b.vy;
      b.life--;

      if (b.life <= 0 || b.x < -60 || b.x > W()+60) {
        bullets.splice(i, 1);
        continue;
      }

      const target = (b.owner === p1) ? bot : p1;
      const rx = target.x - target.w/2;
      const ry = target.y - target.h;

      if (rectHitCircle(rx, ry, target.w, target.h, b.x, b.y, b.r + 2)) {
        target.hp -= 12;
        target.vx += Math.sign(b.vx) * 1.25;
        bullets.splice(i, 1);

        if (target.hp <= 0) {
          const winner = (target === p1) ? bot : p1;

          // point
          if (winner.score >= 4) {
            winner.score++;
            running = false;
            statusEl.textContent = `Match over â€” Final ${p1.score}:${bot.score}`;
            showOverlay(winner === p1 ? "win" : "lose");
          } else {
            resetRound(winner);
          }
        }
      }
    }
  }

  function glowLine(x1,y1,x2,y2,color,w=2) {
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = w;
    ctx.shadowColor = color;
    ctx.shadowBlur = 14;
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x2,y2);
    ctx.stroke();
    ctx.restore();
  }

  function drawPlayer(p, label) {
    const x = p.x, y = p.y;
    const bodyTop = y - p.h;

    // hover ring
    ctx.save();
    ctx.shadowColor = p.color;
    ctx.shadowBlur = 18;
    ctx.strokeStyle = p.color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.ellipse(x, y+2, 18, 7, 0, 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();

    ctx.save();
    ctx.translate(x, bodyTop + 14);

    // head
    ctx.save();
    ctx.shadowColor = p.color;
    ctx.shadowBlur = 16;
    ctx.fillStyle = "rgba(234,247,255,0.07)";
    ctx.strokeStyle = p.color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, 0, 10, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();
    ctx.restore();

    // visor
    ctx.save();
    ctx.fillStyle = "rgba(0,229,255,0.10)";
    ctx.beginPath();
    ctx.ellipse(2, 1, 6, 4, 0.2, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // body
    ctx.save();
    ctx.strokeStyle = neon.white;
    ctx.globalAlpha = 0.8;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, 10);
    ctx.lineTo(0, 26);
    ctx.stroke();
    ctx.restore();

    // arm + gun
    const armY = 16;
    const gunX = p.face * 14;
    glowLine(0, armY, gunX, armY, p.color, 2);

    // legs
    ctx.save();
    ctx.strokeStyle = neon.white;
    ctx.globalAlpha = 0.7;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, 26); ctx.lineTo(-7, 38);
    ctx.moveTo(0, 26); ctx.lineTo(7, 38);
    ctx.stroke();
    ctx.restore();

    // label
    ctx.save();
    ctx.fillStyle = neon.white;
    ctx.globalAlpha = 0.85;
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctx.textAlign = "center";
    ctx.fillText(label, 0, -16);
    ctx.restore();

    // HP tiny pip glow when low
    if (p.hp <= 28) {
      ctx.save();
      ctx.globalAlpha = 0.85;
      glowLine(-10, -10, 10, -10, neon.red, 2);
      ctx.restore();
    }

    ctx.restore();
  }

  function drawUI() {
    const barW = 220, barH = 10;

    function hpBar(x, y, hp, color) {
      ctx.save();
      ctx.fillStyle = "rgba(234,247,255,0.08)";
      ctx.fillRect(x, y, barW, barH);

      const ratio = clamp(hp/100,0,1);
      const glowColor = ratio < 0.3 ? neon.red : color;

      ctx.fillStyle = glowColor;
      ctx.shadowColor = glowColor;
      ctx.shadowBlur = 14;
      ctx.fillRect(x, y, barW * ratio, barH);
      ctx.restore();
    }

    hpBar(14, 14, p1.hp, p1.color);
    hpBar(W()-14-barW, 14, bot.hp, bot.color);

    ctx.save();
    ctx.fillStyle = neon.white;
    ctx.globalAlpha = 0.92;
    ctx.font = "14px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
    ctx.fillText(`${p1.label} ${p1.score}`, 14, 46);
    ctx.textAlign = "right";
    ctx.fillText(`AI ${bot.score}`, W()-14, 46);
    ctx.restore();
  }

  function drawBackground(t) {
    const g = ctx.createLinearGradient(0,0,0,H());
    g.addColorStop(0, "#020617");
    g.addColorStop(1, neon.deep);
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W(),H());

    for (const s of stars) {
      s.x -= s.s;
      if (s.x < -2) { s.x = W()+2; s.y = Math.random()*H(); }

      ctx.save();
      ctx.fillStyle = "rgba(234,247,255,0.7)";
      ctx.globalAlpha = 0.25 + 0.25*Math.sin((t*0.002)+(s.y*0.01));
      ctx.beginPath();
      ctx.arc(s.x*(W()/980), s.y*(H()/420), s.r, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    glowLine(0, H()-18, W(), H()-18, neon.cyan, 2);
  }

  function drawBullets() {
    for (const b of bullets) {
      ctx.save();
      ctx.fillStyle = b.color;
      ctx.shadowColor = b.color;
      ctx.shadowBlur = 18;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
      glowLine(b.x, b.y, b.x - b.vx*2, b.y, b.color, 2);
      ctx.restore();
    }
  }

  let running = true;

  function loop(now) {
    drawBackground(now);

    if (running) {
      updatePlayerHuman(p1);
      updateBotAI(bot);
      updateBullets();
    }

    drawBullets();
    drawPlayer(p1, p1.label);
    drawPlayer(bot, "AI");
    drawUI();

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
